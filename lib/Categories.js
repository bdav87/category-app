const csv = require('fast-csv');
const fs = require('fs');
const EventEmitter = require('events');
const BoolString = require('../lib/helpers/BoolString');

class Categories extends EventEmitter {
    constructor(bcAPI) {
        super();
        this.bcAPI = bcAPI;
        this.Streams = {};
        this.nextPage = '';
    }
    createSample() {
        let category = {
            parent_id: 0,
            name: `Sample Category ${Math.round(Math.random() * 1000000)}`,
            description: 'A sample category generated by the app',
        };
        return this.bcAPI.post('/catalog/categories', category)
    }
    createCSVFile() {
        const date = new Date().toDateString().split(' ').join('');
        const filename = `./exports/category-export-${date}.csv`;
        return filename;
    }
    initExportStream() {
        const filename = this.createCSVFile();
        const writableStream = fs.createWriteStream(filename);
        const csvStream = csv.createWriteStream({headers: true});
        csvStream.pipe(writableStream);

        const Streams = {
            writableStream: writableStream,
            csvStream: csvStream,
            filename: filename
        }
        return Streams;
    }
    initExport() {
        this.Streams = this.initExportStream();
        this.exportCycle('?page=1&limit=250');
    }
    exportCycle(path) {
        this.bcAPI.get(`/catalog/categories${path}`)
        .then(response => {
            const {data, meta} = response;
            this.nextPage = meta.pagination.links.next;
            return this.streamToCSV(data, meta)
        })
        .catch(err => console.log('export cycle err:', err))
    }
    streamToCSV(categories, meta) {
        const category_list = categories.map(category => Object.assign({}, category));
        const {current_page, total_pages} = meta.pagination;
        return this.determinePageForCSV(category_list, current_page, total_pages);
    }
    determinePageForCSV(current_categories, current_page, total_pages) {
        if (current_page < total_pages) {
            current_categories.forEach(this.writeToCSV.bind(this));
        }
        if (current_page == total_pages) {
            current_categories.forEach(this.writeAndPublishCSV.bind(this));
        }
    }
    writeToCSV(category, i, arr) {
        this.Streams.csvStream.write(this.formatExportContent(category))
        if (i == arr.length - 1) {
            const path = this.nextPage;
            return this.exportCycle(path);
        }
    }
    writeAndPublishCSV(category, i, arr) {
        this.Streams.csvStream.write(this.formatExportContent(category));
        if (i == arr.length - 1) {
            this.sendCSV();
        }
    }
    formatExportContent(category) {
        return {
            'Category ID': parseInt(category['id']),
            'Parent ID': parseInt(category['parent_id']),
            'Category Name': category['name'],
            'Category Description': category['description'],
            'Sort Order': category['sort_order'],
            'Page Title': category['page_title'],
            'Meta Keywords': category['meta_keywords'],
            'Meta Description': category['meta_description'],
            'Category Image URL': category['image_url'],
            'Category Visible': BoolString.ToYesNo(category['is_visible']),
            'Search Keywords': category['search_keywords'],
            'Default Product Sort': category['default_product_sort'],
            'Category URL': category['custom_url']['url'],
            'Custom URL': BoolString.ToYesNo(category['custom_url']['is_customized']),
        };
    }
    sendCSV() {
        this.Streams.csvStream.end();
        this.Streams.writableStream.on('finish', () => this.emit('exportReady'));
    }
}

module.exports = Categories;